<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Trdthg's blog</title>

    <link rel="stylesheet" type="text/css" href="../assets/css/prism.css"/>
    <link rel="stylesheet" type="text/css" href="../assets/css/index.css"/>

    <script type="text/javascript">
      function a(obj) {
        obj = obj.nextElementSibling
        for (let childnode of obj.childNodes) {
          if (childnode.hidden != true) {
            childnode.hidden = true
          } else {
            childnode.hidden = false
          }
        }
        return false
      }
    </script>
</head>
<body>
  <div id = "app">
    <div class = "container">
        
      <div class = "nav">
        <div id="">
          <div class="title"><a href="../index.html"><span>Trdthg's blog</span></a></div>
          <div class = "links"> <span class = "nav_lists"><a href="../rust/rust.html">Rust</a></span><span class = "nav_lists"><a href="../other/other.html">其他</a></span><span class = "nav_lists"><a href="../java/java.html">Java</a></span><span class = "nav_lists"><a href="../python/python.html">Python</a></span><span class = "nav_lists"><a href="../https://github.com/trdthg.html">Github</a></span><span class = "nav_lists"><a href="../js/js.html">前端</a></span> </div>
        </div>
      </div>

      <div class = "sidebar"> <div class="desc h1" onclick="return a(this)"><a href="#ITsZ"><span>Too-Many-Lists</span></a></div><div class="more"><div class="desc h2" onclick="return a(this)"><a href="#MNJZ"><span>A Bad Stack</span></a></div><div class="more"><div class="item h3" ><a href="#CeT5"><span>引例</span></a></div><div class="item h3" ><a href="#WKWC"><span>完整案例</span></a></div><div class="item h3" ><a href="#4yTj"><span>Drop的手动编写</span></a></div><div class="item h3"><a href="#BQOY"><span>unimplemented!</span></a></div></div><div class="desc h2" onclick="return a(this)"><a href="#oaLc"><span>An Ok Singly-Linked Stack</span></a></div><div class="more"><div class="item h3" ><a href="#gpxq"><span>优化目标</span></a></div><div class="item h3" ><a href="#Q85G"><span>Option &amp; Generic</span></a></div><div class="item h3" ><a href="#w4fd"><span>Peek</span></a></div><div class="item h3" ><a href="#e-pB"><span>IntoIter</span></a></div><div class="item h3" ><a href="#EoP5"><span>Iter</span></a></div><div class="item h3"><a href="#RaKT"><span></span></a></div></div><div class="desc h2" onclick="return a(this)"><a href="#EaJc"><span>A Persistent Stack</span></a></div><div class="more"><div class="item h3" ><a href="#e-0G"><span>实现目标</span></a></div><div class="item h3" ><a href="#oN_F"><span>Basic</span></a></div><div class="item h3" ><a href="#rVx_"><span>Iter</span></a></div><div class="item h3" ><a href="#I7k5"><span>Drop</span></a></div><div class="item h3"><a href="#rkOG"><span>Test</span></a></div></div><div class="desc h2" onclick="return a(this)"><a href="#7Zp3"><span>A Bad Safe Deque</span></a></div><div class="more"><div class="item h3" ><a href="#BFPu"><span>Layout</span></a></div><div class="item h3" ><a href="#6SVv"><span>Basic</span></a></div><div class="item h3" ><a href="#bA0-"><span>Drop</span></a></div><div class="item h3" ><a href="#fVxk"><span>IntoIter</span></a></div><div class="item h3"><a href="#TmqQ"><span>Iter(danger)</span></a></div></div><div class="desc h2" onclick="return a(this)"><a href="#iHva"><span>An Unsafe Queue</span></a></div><div class="more"><div class="desc h3" onclick="return a(this)"><a href="#-yEl"><span>Safe Rust</span></a></div><div class="more"><div class="item h4" ><a href="#afRp"><span>Push</span></a></div><div class="item h4"><a href="#rifs"><span>Pop</span></a></div></div><div class="item h3" ><a href="#xi90"><span>Layout</span></a></div><div class="item h3" ><a href="#7QhX"><span>Extras</span></a></div><div class="item h3"><a href="#i4Nl"><span>Test</span></a></div></div></div></div></div>

      <div class = "page">
        <div class = "content"><h1 id="ITsZ">Too-Many-Lists</h1><h2 id="MNJZ">A Bad Stack</h2><h3 id="CeT5">引例</h3><p>/**</p><ul><li>用这种方式会有标签带来的额外开销, 属于函数式编程语言的默认方法</li><li>所以用下面的C-like结构体形式占用空间更小,</li><li>而且单个节点能承载更多内容<br />*/</li></ul><pre><code class="language-rust">#[derive(Debug)]pub enum List&lt;T&gt; {    Empty,    Elem(T, Box&lt;List&lt;T&gt;&gt;),}</code></pre><h3 id="WKWC">完整案例</h3><pre><code class="language-rust">// 2.1. Layoutpub struct List {    head: Link,}enum Link {    Empty,    More(Box&lt;Node&gt;),}struct Node {    elem: i32,    next: Link,}use std::mem;impl List {    // 2.2. New    pub fn new() -&gt; Self {        List {            head: Link::Empty,        }    }    // 2.4. Push    pub fn push(&amp;mut self, elem: i32) {        let new_node = Box::new(Node {             elem,             next: mem::replace(&amp;mut self.head, Link::Empty),         });        self.head = Link::More(new_node)    }    // 2.5. Pop     // 相比于上一个更常用而且更简洁的写法    pub fn pop(&amp;mut self) -&gt; Option&lt;i32&gt; {        match mem::replace(&amp;mut self.head, Link::Empty) {            Link::Empty =&gt; None,            Link::More(node) =&gt; {                self.head = node.next;                Some(node.elem)            }        }    }}// 2.6. Testing#[cfg(test)]mod test {    #[test]    fn basics() {        // TODO        use super::*;        let mut list = List::new();        // Check empty list behaves right        assert_eq!(list.pop(), None);        // Populate list        list.push(1);        list.push(2);        list.push(3);        // Check normal removal        assert_eq!(list.pop(), Some(3));        assert_eq!(list.pop(), Some(2));        // Push some more just to make sure nothing's corrupted        list.push(4);        list.push(5);        // Check normal removal        assert_eq!(list.pop(), Some(5));        assert_eq!(list.pop(), Some(4));        // check exhaustion        assert_eq!(list.pop(), Some(1));        assert_eq!(list.pop(), None);        // Check drop        list.push(1);        list.push(2);        list.push(3);    }}</code></pre><h3 id="4yTj">Drop的手动编写</h3><p>尝试根据尾递归写出drop函数, 失败</p><pre><code class="language-rust">// 2.7. Dropimpl Drop for List {    fn drop(&amp;mut self) {        self.head.drop();    }}impl Drop for Link {    fn drop(&amp;mut self) {        match self {            Link::Empty =&gt; {},            Link::More(ref mut boxed_node) =&gt; {                boxed_node.drop();            }        }    }}impl Drop for Box&lt;Node&gt; {    fn drop(&amp;mut self) {        self.ptr.drop();   // uh oh, not tail recursive!        deallocate(self.ptr);    }}impl Drop for Node {    fn drop(&amp;mut self) {        self.next.drop();    }}</code></pre><p>::: danger</p><blockquote><p>We can't drop the contents of the Box after deallocating, so there's no way to drop in a tail-recursive manner!Instead we're going to have to manually write an iterative drop for List that hoists nodes out of their boxes.:::So, the next is the real way to write drop ourselfs</p></blockquote><pre><code class="language-rust">impl Drop for List {    fn drop(&amp;mut self) {        println!(&quot;开始drop&quot;);        let mut cur_link = mem::replace(&amp;mut self.head, Link::Empty);        while let Link::More(mut boxed_node) = cur_link {            println!(&quot;{}&quot;, boxed_node.elem);            cur_link = mem::replace(&amp;mut boxed_node.next, Link::Empty);        }    }}</code></pre><h3 id="BQOY">unimplemented!</h3><p>::: warning</p><pre><code class="language-rust">// 返回 unimplemented!()impl List {    pub fn pop(&amp;mut self) -&gt; Option&lt;i32&gt; {        match &amp;self.head {            Link::Empty =&gt; {                // TODO            },            Link::More(node) =&gt; {                // TODO            }        }        unimplemented!()    }}</code></pre><p>:::</p><h2 id="oaLc">An Ok Singly-Linked Stack</h2><h3 id="gpxq">优化目标</h3><ol><li>3.1: Option 简化语法</li></ol><ul><li>use Option to replace our own Enum</li><li>use Option.take() to replace mem::replace(&amp;self, None)</li><li>use option.take().map(|elem {}|) to replace match option { None =&gt; None, Some(x) =&gt; Some(y) }</li></ul><ol start="2"><li>3.2 Generic 通用性</li></ol><ul><li>just use T to replace i32</li></ul><ol start="3"><li>3.3 Peek(偷看) 实现peek</li></ol><ul><li></li><li>注意3者的区别</li><li>self.head.take()    -&gt; self       -&gt; Option(T)</li><li>self.head.as_ref()  -&gt; &amp;self      -&gt; Option(&amp;T)</li><li>self.head.as_mut()  -&gt; &amp;mut self  -&gt; Option(&amp;mut T)</li></ul><ol start="4"><li>3.4 - 3.6 三种迭代器</li></ol><ul><li>IntoIter - T</li><li>IterMut - &amp;mut T</li><li>Iter - &amp;T</li></ul><blockquote><p>map(): Maps an Option<!-- raw HTML omitted --> to Option<!-- raw HTML omitted --> by applying a function to a contained value.as_ref()-&gt;&amp;self: Converts from &amp;Option<!-- raw HTML omitted --> to Option&lt;&amp;T&gt;.as_mut()-&gt;&amp;mut self: Converts from &amp;mut Option<!-- raw HTML omitted --> to Option&lt;&amp;mut T&gt;.take()-&gt;&amp;mut self: Takes the value out of the option, leaving a [None] in its place</p></blockquote><h3 id="Q85G">Option &amp; Generic</h3><pre><code class="language-rust">use std::mem;#[derive(Debug)]pub struct List&lt;T&gt; {    head: Link&lt;T&gt;,}type Link&lt;T&gt; = Option&lt;Box&lt;Node&lt;T&gt;&gt;&gt;;#[derive(Debug)]struct Node&lt;T&gt; {    elem: T,    next: Link&lt;T&gt;,}impl&lt;T&gt; List&lt;T&gt; {    // 2.2. New    pub fn new() -&gt; Self {        List { head: None }    }    // 2.4. Push    pub fn push(&amp;mut self, elem: T) {        let new_node = Box::new(Node {             elem,             // next: mem::replace(&amp;mut self.head, None),             next: self.head.take(),         });        self.head = Some(new_node);    }    // 2.5. Pop     pub fn pop(&amp;mut self) -&gt; Option&lt;T&gt; {        self.head.take().map(|node| {            self.head = node.next;            node.elem  //  node.elem not need to be wrapped by Some()        })    }    }</code></pre><h3 id="w4fd">Peek</h3><pre><code class="language-rust">impl&lt;T&gt; List&lt;T&gt; {    /*    impl&lt;T&gt; Option&lt;T&gt; {        pub fn as_ref(&amp;self) -&gt; Option&lt;&amp;T&gt;;    }    */    pub fn peek(&amp;self) -&gt; Option&lt;&amp;T&gt; {        // Converts from &amp;Option&lt;T&gt; to Option&lt;&amp;T&gt;.        // self             -&gt; &amp;List          // self.head        -&gt; &amp;Option&lt; Box&lt;Node&lt;T&gt;&gt;&gt;        // self.head.as_ref -&gt;  Option&lt;&amp;Box&lt;Node&lt;T&gt;&gt;&gt;        // map(node)        -&gt;         &amp;Box&lt;Node&lt;T&gt;&gt;        // node.elem        -&gt;                   T        // &amp;node.elem       -&gt;         &amp;         T        // map-&gt;&amp;node.elem  -&gt;  Option&lt;&amp;         T  &gt;        self.head.as_ref().map(|node| {            &amp;node.elem        })    }    pub fn peek_mut(&amp;mut self) -&gt; Option&lt;&amp;mut T&gt; {        // Converts from &amp;mut Option&lt;T&gt; to Option&lt;&amp;mut T&gt;.        // self             -&gt; &amp;mut List          // self.head        -&gt; &amp;mut Option&lt;     Box&lt;Node&lt;T&gt;&gt;&gt;        // self.head.as_mut -&gt;      Option&lt;&amp;mut Box&lt;Node&lt;T&gt;&gt;&gt;        // map(node)        -&gt;             &amp;mut Box&lt;Node&lt;T&gt;&gt;        // node.elem        -&gt;                           T        // &amp;mut node.elem   -&gt;             &amp;mut          T        // map-&gt;&amp;node.elem  -&gt;      Option&lt;&amp;mut          T  &gt;        self.head.as_mut().map(|node| {            &amp;mut node.elem        })    }    pub fn peek_(&amp;mut self) -&gt; Option&lt;T&gt; {        // warning(not sure): mut_only_in_this_fu_but_only_read_after_read        // Takes the value out of the option, leaving a [None] in its place        // self             -&gt; &amp;mut List          // self.head        -&gt; &amp;mut Option&lt;     Box&lt;Node&lt;T&gt;&gt;&gt;        // self.head.take   -&gt;      Option&lt;&amp;mut Box&lt;Node&lt;T&gt;&gt;&gt;        // self.head        -&gt; &amp;mut Option&lt;None&gt;        // temp             -&gt; &amp;mut Option&lt;     Box&lt;Node&lt;T&gt;&gt;&gt;        // map(node)        -&gt;                  Box&lt;Node&lt;T&gt;&gt;        // node.elem        -&gt;                           T        // map-&gt;node.elem   -&gt;      Option&lt;              T  &gt;        self.head.take().map(|node| {            node.elem        })    }    }#[test]fn peek() {    let mut list = List::new();    assert_eq!(list.peek(), None);    assert_eq!(list.peek_mut(), None);    list.push(1); list.push(2); list.push(3);    assert_eq!(list.peek(), Some(&amp;3));    assert_eq!(list.peek_mut(), Some(&amp;mut 3));    // match list.peek_mut() {    //     Some(k) =&gt; {*k = 30},    //     None =&gt; {}    // }    list.peek_mut().map(|val| {        *val = 30;    });    assert_eq!(list.peek_mut(), Some(&amp;mut 30));    if let Some(val) = list.peek_mut() {        println!(&quot;{}&quot;, val);        *val = 10;    }    assert_eq!(list.peek_mut(), Some(&amp;mut 10));    assert_eq!(list.pop(), Some(10));    assert_eq!(list.peek(), Some(&amp;2));    if let Some(val) = list.peek_() {        println!(&quot;{}&quot;, val);    }}</code></pre><h3 id="e-pB">IntoIter</h3><pre><code class="language-rust">// 3.4 IntoIter------------------------------------------------------------------------------pub struct IntoIter&lt;T&gt;(List&lt;T&gt;);impl&lt;T&gt; List&lt;T&gt; {    pub fn into_iter(self) -&gt; IntoIter&lt;T&gt; {        IntoIter(self)    }}impl&lt;T&gt; Iterator for IntoIter&lt;T&gt; {    type Item = T;    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {        self.0.pop()    }}#[test]fn into_iter_test() {    let mut list = List::new();    list.push(1);    list.push(2);    list.push(3);    let mut iter = list.into_iter();    assert_eq!(iter.next(), Some(3));    assert_eq!(iter.next(), Some(2));}</code></pre><h3 id="EoP5">Iter</h3><pre><code class="language-rust">// 3.5 Iter------------------------------------------------------------------------------pub struct Iter&lt;'a, T&gt; {    next: Option&lt;&amp;'a Node&lt;T&gt;&gt;}impl&lt;T&gt; List&lt;T&gt; {    // 1. initial    // pub fn iter&lt;'a&gt;(&amp;'a self) -&gt; Iter&lt;'a, T&gt; {    // 2. apply lifetime elision    // pub fn iter(&amp;self) -&gt; Iter&lt;T&gt; {    // 3. Or, if you're not comfortable &quot;hiding&quot; that a struct contains a lifetime, you can use the Rust 2018 &quot;explicitly elided lifetime&quot; syntax, '_:    pub fn iter(&amp;self) -&gt; Iter&lt;'_, T&gt; {                // self             -&gt; &amp;List                    | self                -&gt; &amp;List          // self.head        -&gt; &amp;Option&lt; Box&lt;Node&lt;T&gt;&gt;&gt;   | self.head           -&gt; &amp;Option&lt; Box&lt;Node&lt;T&gt;&gt;&gt;         // self.head.as_ref -&gt;  Option&lt;&amp;Box&lt;Node&lt;T&gt;&gt;&gt;   | self.head.as_deref  -&gt; &amp;Option&lt;     Node&lt;T&gt; &gt;        // map(node)        -&gt;         &amp;Box&lt;Node&lt;T&gt;&gt;    |        // *node            -&gt;          Box&lt;Node&lt;T&gt;&gt;    |        // **node           -&gt;              Node&lt;T&gt;     |        // &amp;**node          -&gt;             &amp;Node&lt;T&gt;     |        // map-&gt;node        -&gt;  Option&lt;    &amp;Node&lt;T&gt; &gt;   |        // can be replaced by the next line        Iter { next: self.head.as_ref().map(|node| { &amp;**node }) }        // Iter { next: self.head.as_deref() }        // node: expected struct `second::Node`, found struct `std::boxed::Box`        // *node: expected `&amp;second::Node&lt;T&gt;`, found struct `std::boxed::Box`        // **node: expected `&amp;second::Node&lt;T&gt;`, found struct `second::Node`    }}impl&lt;'a, T&gt; Iterator for Iter&lt;'a, T&gt; {    type Item = &amp;'a T;    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {        // self                  -&gt; &amp;mut Iter                           | self                   -&gt; &amp;mut Iter          // self.next             -&gt; &amp;mut Option&lt;         &amp;Node&lt;T&gt; &gt;     | self.next              -&gt; &amp;mut Option&lt;         &amp;Node&lt;T&gt;&gt;          // map(node)             -&gt; &amp;mut                 &amp;Node&lt;T&gt;       | map(node)              -&gt; &amp;mut                 &amp;Node&lt;T&gt;        //     node.next         -&gt; &amp;mut Option&lt;         &amp;Node&lt;T&gt; &gt;     |     node.next          -&gt; &amp;mut Option&lt;     Box&lt; Node&lt;T&gt;&gt;&gt;        //     node.next.as_ref  -&gt;      Option&lt;&amp;mut Box&lt; Node&lt;T&gt;&gt;&gt;     |     node.next.as_deref -&gt; &amp;mut Option&lt;          Node&lt;T&gt; &gt;         //     map(inner_node)   -&gt;             &amp;mut Box&lt; Node&lt;T&gt;&gt;      |        //     *inner_node       -&gt;                  Box&lt; Node&lt;T&gt;&gt;      |        //     **inner_node      -&gt;                       Node&lt;T&gt;       |        //     &amp;**inner_node     -&gt;                      &amp;Node&lt;T&gt;       |        //     map(inner_node)   -&gt;      Option&lt;         &amp;Node&lt;T&gt; &gt;     |        // self.next             -&gt; &amp;mut Option&lt;         &amp;Node&lt;T&gt;&gt;      | self.next              -&gt; &amp;mut Option&lt;&amp; Node&lt;T&gt;&gt;        // node.elem             -&gt; &amp;mut                       T        |        // &amp;node.elem            -&gt; &amp;mut                      &amp;T        |        // map-&gt;&amp;node.elem       -&gt; &amp;mut Option&lt;              &amp;T &gt;      |        self.next.map(|node| {            self.next = (*node).next.as_ref().map(|node| &amp;**node);            // self.next = node.next.as_deref();            // self.next = node.next.as_ref().map::&lt;&amp;Node&lt;T&gt;, _&gt;(|node| &amp;node);            // node.next = Some(Box::new(Node{elem: 1, next: None}));            &amp;node.elem        })    }}#[test]fn iter() {    let mut list = List::new();    list.push(1); list.push(2); list.push(3);    let mut iter = list.iter();    assert_eq!(iter.next(), Some(&amp;3));    assert_eq!(iter.next(), Some(&amp;2));    assert_eq!(iter.next(), Some(&amp;1));}</code></pre><h3 id="RaKT"></h3><h2 id="EaJc">A Persistent Stack</h2><h3 id="e-0G">实现目标</h3><pre><code>list1 = A -&gt; B -&gt; C -&gt; Dlist2 = tail(list1) = B -&gt; C -&gt; Dlist3 = push(list2, X) = X -&gt; B -&gt; C -&gt; Dlist1 -&gt; A ---+              |              vlist2 ------&gt; B -&gt; C -&gt; D              ^              |list3 -&gt; X ---+</code></pre><h3 id="oN_F">Basic</h3><pre><code class="language-rust">use std::rc::Rc;// basic -------------------------------------------------------------------pub struct List&lt;T&gt; {    head: Link&lt;T&gt;}type Link&lt;T&gt; = Option&lt;Rc&lt;Node&lt;T&gt;&gt;&gt;;struct Node&lt;T&gt; {    elem: T,    next: Link&lt;T&gt;,}impl&lt;T&gt; List&lt;T&gt; {    pub fn new() -&gt; List&lt;T&gt; {        List { head: None }    }    pub fn prepend(&amp;self, elem: T) -&gt; List&lt;T&gt; {        List { head: Some(Rc::new(Node { elem, next: self.head.clone() })) }    }    pub fn tail(&amp;self) -&gt; List&lt;T&gt; {        List { head: self.head.as_ref().and_then(|node| node.next.clone()) }    }    pub fn head(&amp;self) -&gt; Option&lt;&amp;T&gt; {        self.head.as_ref().map(|node| &amp;node.elem)    }}</code></pre><h3 id="rVx_">Iter</h3><pre><code class="language-rust">// Iter ------------------------------------------------------------------pub struct Iter&lt;'a, T&gt; {    next: Option&lt;&amp;'a Node&lt;T&gt;&gt;}impl&lt;'a, T&gt; Iterator for Iter&lt;'a, T&gt; {    type Item = &amp;'a T;    fn next(&amp;mut self) -&gt; Option&lt;&amp;'a T&gt; {        self.next.map(|node| {            self.next = node.next.as_ref().map(|node| &amp;**node);            &amp;node.elem        })    }}impl&lt;T&gt; List&lt;T&gt; {    pub fn iter(&amp;self) -&gt; Iter&lt;T&gt; {        Iter { next: self.head.as_ref().map(|node| &amp;**node) }    }}</code></pre><h3 id="I7k5">Drop</h3><p>多了判断ref count的过程</p><pre><code class="language-rust">// drop ------------------------------------------------------------impl&lt;T&gt; Drop for List&lt;T&gt; {    fn drop(&amp;mut self) {        let mut head = self.head.take();        while let Some(node) = head {            if let Ok(mut node) = Rc::try_unwrap(node) {                head = node.next.take();            } else {                break            }        }    }}</code></pre><h3 id="rkOG">Test</h3><pre><code class="language-rust">#[cfg(Test)]mod test {    use super::List;    #[test]    fn basics_test() {        let list = List::new();        list.prepend(1).prepend(2).prepend(3);                assert_eq!(list.head(), Some(&amp;3));        let list = list.tail();        assert_eq!(list.head(), Some(&amp;2));        let list = list.tail();        assert_eq!(list.head(), Some(&amp;1));        let list = list.tail();        assert_eq!(list.head(), None);        let list = list.tail();        assert_eq!(list.head(), None);    }    #[test]    fn iter_test() {        let list = List::new().prepend(1).prepend(2).prepend(3);        let mut iter = list.iter();        assert_eq!(iter.next(), Some(&amp;3));        assert_eq!(iter.next(), Some(&amp;2));        assert_eq!(iter.next(), Some(&amp;1));    }}</code></pre><h2 id="7Zp3">A Bad Safe Deque</h2><p>加入了Rc和RefCell</p><h3 id="BFPu">Layout</h3><pre><code class="language-rust">se std::rc::Rc;use std::cell::{ Ref, RefMut, RefCell };pub struct List&lt;T&gt; {    head: Link&lt;T&gt;,    tail: Link&lt;T&gt;,}type Link&lt;T&gt; = Option&lt;Rc&lt;RefCell&lt;Node&lt;T&gt;&gt;&gt;&gt;;struct Node&lt;T&gt; {    elem: T,    next: Link&lt;T&gt;,    prev: Link&lt;T&gt;,} </code></pre><h3 id="6SVv">Basic</h3><pre><code class="language-rust">impl&lt;T&gt; List&lt;T&gt; {    pub fn new() -&gt; List&lt;T&gt; {        List { head: None, tail: None }    }    // 5.2 Building下`    pub fn push_front(&amp;mut self, elem: T) {        let new_head = Node::new(elem);        match self.head.take() {            Some(old_head) =&gt; {                old_head.borrow_mut().prev = Some(new_head.clone());                new_head.borrow_mut().next = Some(old_head);                self.head = Some(new_head);            },            None =&gt; {                self.head = Some(new_head.clone());                self.tail = Some(new_head);            }        }    }    // 5.3 Breaking    pub fn pop_front(&amp;mut self) -&gt; Option&lt;T&gt; {        self.head.take().map(|old_head| {            // 临时借用old_head, 并take了next的ownership            match old_head.borrow_mut().next.take() {                Some(new_head) =&gt; {                    new_head.borrow_mut().prev = None;                    self.head = Some(new_head);                }                None =&gt; {                    self.tail.take();                }            }            Rc::try_unwrap(old_head).ok().unwrap().into_inner().elem        })    }    // 5.4 Peeking    // pub fn peek(&amp;self) -&gt; Option&lt;&amp;T&gt; {    //     self.head.as_ref().map(|node| {    //         // Rc::try_unwrap(node).ok().unwrap().into_inner().elem    //         // &amp;node.borrow().elem    //     })    // }    pub fn peek_front(&amp;self) -&gt; Option&lt;Ref&lt;T&gt;&gt; {        self.head.as_ref().map(|node| {            Ref::map(node.borrow(), |node| &amp;node.elem)        })    }    pub fn peek_front_mut(&amp;mut self) -&gt; Option&lt;RefMut&lt;T&gt;&gt; {        self.head.as_ref().map(|node| {            RefMut::map(node.borrow_mut(), |node| &amp;mut node.elem)        })    }    // Back ---------------------------------------------------------    pub fn push_back(&amp;mut self, elem: T) {        let new_tail = Node::new(elem);        match self.tail.take() {            Some(old_tail) =&gt; {                old_tail.borrow_mut().next = Some(new_tail.clone());                new_tail.borrow_mut().prev = Some(old_tail.clone());                self.tail = Some(new_tail);            }            None =&gt; {                self.head = Some(new_tail.clone());                self.tail = Some(new_tail);            }        }    }    pub fn pop_back(&amp;mut self) -&gt; Option&lt;T&gt; {        self.tail.take().map(|old_tail| {            match old_tail.borrow_mut().prev.take() {                Some(new_tail) =&gt; {                    new_tail.borrow_mut().next.take();                    self.tail = Some(new_tail);                }                None =&gt; {                    self.head = None;                }            }             Rc::try_unwrap(old_tail).ok().unwrap().into_inner().elem        })    }    pub fn peek_back(&amp;self) -&gt; Option&lt;Ref&lt;T&gt;&gt; {        self.tail.as_ref().map(|node| {            Ref::map(node.borrow(), |node| &amp;node.elem)        })    }    pub fn peek_back_mut(&amp;mut self) -&gt; Option&lt;RefMut&lt;T&gt;&gt; {        self.tail.as_ref().map(|node| {            RefMut::map(node.borrow_mut(), |node| &amp;mut node.elem)        })    }}impl&lt;T&gt; Node&lt;T&gt; {    pub fn new(elem: T) -&gt; Rc&lt;RefCell&lt;Node&lt;T&gt;&gt;&gt; {        Rc::new(RefCell::new(Node {            elem,            next:None,            prev: None,        }))    }}</code></pre><h3 id="bA0-">Drop</h3><pre><code class="language-rust">impl&lt;T&gt; Drop for List&lt;T&gt; {    fn drop(&amp;mut self) {        while self.pop_front().is_some() {}    } }</code></pre><h3 id="fVxk">IntoIter</h3><p>另一个方向直接实现DoubleEndedIterator Trait就行</p><pre><code class="language-rust">// IntoIterpub struct IntoIter&lt;T&gt;(List&lt;T&gt;);impl&lt;T&gt; List&lt;T&gt; {    pub fn into_iter(self) -&gt; IntoIter&lt;T&gt; {        IntoIter(self)    }}// naturalimpl&lt;T&gt; Iterator for IntoIter&lt;T&gt; {    type Item = T;    fn next(&amp;mut self) -&gt; Option&lt;T&gt; {        self.0.pop_front()    }}// reverseimpl&lt;T&gt; DoubleEndedIterator for IntoIter&lt;T&gt; {    fn next_back(&amp;mut self) -&gt; Option&lt;T&gt; {        self.0.pop_back()    }}</code></pre><h3 id="TmqQ">Iter(danger)</h3><p>::: danger无法实现而且根本看不懂, 一头雾水:::</p><pre><code class="language-rust">// Iterpub struct Iter&lt;'a, T&gt;(Option&lt;Ref&lt;'a, Node&lt;T&gt;&gt;&gt;);impl&lt;T&gt; List&lt;T&gt; {    pub fn iter(&amp;self) -&gt; Iter&lt;T&gt; {        Iter(self.head.as_ref().map(|head| {head.borrow()}))        // 若为 Ref&lt;T&gt;        // Iter(self.head.as_ref().map(|head| {Ref::map(head.borrow(), |head| &amp;head.elem)}))    }}impl&lt;'a, T&gt; Iterator for Iter&lt;'a, T&gt; {    type Item = Ref&lt;'a, T&gt;;    fn next(&amp;mut self) -&gt; Option&lt;Ref&lt;'a, T&gt;&gt; {        self.0.take().map(|node_ref| {            // self.0 = node_ref.next.as_ref().map(|head| {head.borrow()});            // // node_ref在闭包内被借用            // Ref::map(node_ref, |node| &amp;node.elem)            // // node_ref在闭包外再次被借用            let (next, elem) = Ref::map_split(node_ref, |node| {                (&amp;node.next, &amp;node.elem)            });            self.0 = next.as_ref().map(|head| head.borrow());            elem        })    }   }</code></pre><h2 id="iHva">An Unsafe Queue</h2><h3 id="-yEl">Safe Rust</h3><p>Well, pushing is actually fine.</p><h4 id="afRp">Push</h4><pre><code class="language-rust">// An Unsafe Queue/*input list:[Some(ptr)] -&gt; (A, Some(ptr)) -&gt; (B, None)flipped push X:[Some(ptr)] -&gt; (A, Some(ptr)) -&gt; (B, Some(ptr)) -&gt; (X, None)*/// Layoutpub struct List&lt;'a, T&gt; {    head: Link&lt;T&gt;,    tail: Option&lt;&amp;'a mut Node&lt;T&gt;&gt;,}type Link&lt;T&gt; = Option&lt;Box&lt;Node&lt;T&gt;&gt;&gt;;struct Node&lt;T&gt; {    elem: T,    next: Link&lt;T&gt;,}// Basicimpl&lt;'a, T&gt; List&lt;'a, T&gt; {    pub fn new() -&gt; List&lt;'a, T&gt; {        List { head: None, tail: None }    }    pub fn push(&amp;'a mut self, elem: T) {        let new_tail = Box::new(Node {            elem: elem,            // When you push onto the tail, your next is always None            next: None,        });        // Put the box in the right place, and then grab a reference to its Node        match self.tail.take() {            Some(old_tail) =&gt; {                // If the old tail existed, update it to point to the new tail                old_tail.next = Some(new_tail);                self.tail = old_tail.next.as_deref_mut()            }            None =&gt; {                // Otherwise, update the head to point to it                self.head = Some(new_tail);                self.tail = self.head.as_deref_mut()            }        };    }}</code></pre><h4 id="rifs">Pop</h4><blockquote><p>However pop is another story. If they're popping elements outside of our range, it should still be fine. We can't see those nodes so nothing will happen. However if they try to pop off the node we're pointing at... &gt;everything will blow up! In particular when they go to unwrap the result of the try_unwrap, it will actually fail, and the whole program will panic.</p></blockquote><pre><code class="language-rust">pub fn pop(&amp;mut self) -&gt; Option&lt;T&gt; {    self.head.take().map(|head| {        let head = *head;        self.head = head.next;        if self.head.is_none() {            self.tail = None;        }        head.elem    })}</code></pre><h3 id="xi90">Layout</h3><pre><code class="language-rust">// Layoutpub struct List&lt;T&gt; {    head: Link&lt;T&gt;,    tail: *mut Node&lt;T&gt;,}type Link&lt;T&gt; = Option&lt;Box&lt;Node&lt;T&gt;&gt;&gt;;struct Node&lt;T&gt; {    elem: T,    next: Link&lt;T&gt;,}use std::ptr;impl&lt;T&gt; List&lt;T&gt; {    pub fn new() -&gt; Self {        List { head: None, tail:  ptr::null_mut()}    }    pub fn push(&amp;mut self, elem: T) {        let mut new_tail = Box::new(Node {            elem,            next: None,        });        let raw_tail: *mut _ = &amp;mut *new_tail;        if !self.tail.is_null() {            unsafe {                (*self.tail).next = Some(new_tail);            }        } else {            self.head = Some(new_tail);        }        self.tail = raw_tail;    }    pub fn pop(&amp;mut self) -&gt; Option&lt;T&gt; {        self.head.take().map(|head| {            let head = *head;            self.head = head.next;            if self.head.is_none() {                self.tail = ptr::null_mut()            };            head.elem        })    }} </code></pre><h3 id="7QhX">Extras</h3><pre><code class="language-rust">pub struct IntoIter&lt;T&gt;(List&lt;T&gt;);pub struct Iter&lt;'a, T&gt; {    next: Option&lt;&amp;'a Node&lt;T&gt;&gt;}pub struct IterMut&lt;'a, T&gt; {    next: Option&lt;&amp;'a mut Node&lt;T&gt;&gt;}impl&lt;T&gt; List&lt;T&gt; {    pub fn peek(&amp;self) -&gt; Option&lt;&amp;T&gt; {        self.head.as_ref().map(|node| {            &amp;node.elem        })    }    pub fn peek_mut(&amp;mut self) -&gt; Option&lt;&amp;mut T&gt; {        self.head.as_mut().map(|node| {            &amp;mut node.elem        })    }    pub fn into_iter(self) -&gt; IntoIter&lt;T&gt; {        IntoIter(self)    }    pub fn iter(&amp;self) -&gt; Iter&lt;T&gt; {        Iter { next: self.head.as_deref() }    }    pub fn iter_mut(&amp;mut self) -&gt; IterMut&lt;T&gt; {        IterMut { next: self.head.as_deref_mut() }    }}impl&lt;T&gt; Iterator for IntoIter&lt;T&gt; {    type Item = T;    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {        self.0.pop()    }}impl&lt;'a, T&gt; Iterator for Iter&lt;'a, T&gt; {    type Item = &amp;'a T;    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {        self.next.map(|node| {            self.next = node.next.as_deref();            &amp;node.elem        })    }}impl&lt;'a, T&gt; Iterator for IterMut&lt;'a, T&gt; {    type Item = &amp;'a mut T;    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {        self.next.take().map(|node| {            self.next = node.next.as_deref_mut();            &amp;mut node.elem        })    }}</code></pre><h3 id="i4Nl">Test</h3><pre><code class="language-rust">mod test {    use super::List;    #[test]    fn basics() {        let mut list = List::new();        // Check empty list behaves right        assert_eq!(list.pop(), None);        // Populate list        list.push(1);        list.push(2);        list.push(3);        // Check normal removal        assert_eq!(list.pop(), Some(1));        assert_eq!(list.pop(), Some(2));        // Push some more just to make sure nothing's corrupted        list.push(4);        list.push(5);        // Check normal removal        assert_eq!(list.pop(), Some(3));        assert_eq!(list.pop(), Some(4));        // Check exhaustion        assert_eq!(list.pop(), Some(5));        assert_eq!(list.pop(), None);    }    #[test]    fn into_iter() {        let mut list = List::new();        list.push(1); list.push(2); list.push(3);        let mut iter = list.into_iter();        assert_eq!(iter.next(), Some(1));        assert_eq!(iter.next(), Some(2));        assert_eq!(iter.next(), Some(3));        assert_eq!(iter.next(), None);    }    #[test]    fn iter() {        let mut list = List::new();        list.push(1); list.push(2); list.push(3);        let mut iter = list.iter();        assert_eq!(iter.next(), Some(&amp;1));        assert_eq!(iter.next(), Some(&amp;2));        assert_eq!(iter.next(), Some(&amp;3));        assert_eq!(iter.next(), None);    }    #[test]    fn iter_mut() {        let mut list = List::new();        list.push(1); list.push(2); list.push(3);        let mut iter = list.iter_mut();        assert_eq!(iter.next(), Some(&amp;mut 1));        assert_eq!(iter.next(), Some(&amp;mut 2));        assert_eq!(iter.next(), Some(&amp;mut 3));        assert_eq!(iter.next(), None);    }}</code></pre></div>
      </div>
      
    </div>
  </div>
  <script src="../assets/js/prism.js"></script>
</body>
</html>